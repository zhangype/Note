1、类的基本类型成员变量可以不初始化。“局部”的基本类型变量需要初始化。
2、javadoc只能为public、protected成员进行文档注释。
3、垃圾回收器只负责释放经由new分配的内存。
4、一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。
5、finalize()的主要用于回收“以非创建对象的方式分配的内存”，例如Java中调用了非Java的方式（C语言中的malloc()分配的存储空间）。
6、只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总得不到释放。如果程序执行结束，并且垃圾回收器一直没有释放你创建的任何对象空间，则随着程序的退出，那些资源也会全部交还给操作系统。
7、System.gc()用于强制进行终结动作，触发回收逻辑由JVM决定。
8、static变量只有类被调用的时候，才会初始化，且只初始化一次。
9、“{}”代码块在构造器之前被调用。
10、编译器不允许声明时指定数组大小。
11、创建enum时，编译器自动实现toString()、ordinal()用来表示某个特定enum常量的声明顺序、values()按照enum常量的声明顺序，产生有这些常量值构成的数组。
12、若默认构造器是private，则该类不允许被继承。
13、构造器也是static方法。
14、编译单元可以不包含public类，此时编译单元可以随意命名。
15、final方法：1）将方法锁定，防止任何继承类修改其含义。保证在继承中方法行为保持不变，并不会被覆盖。
16、所有的private都隐式地指定fianl。
17、方法中的fianl入参，允许读参数，但不允许修改参数。该特性主要用来向匿名内部类传递数据。
18、方法调用绑定：将一个方法调用同一个方法主体关联起来被称作绑定。1）前期绑定：程序执行前进行绑定。2）后期绑定：运行时根据对象的类型进行绑定。
19、java中除了static和final方法之外，其它的都是后期绑定。
20、由于静态方法与类关联而不是与对象关联，所以静态方法不具备多态性。
21、导出类初始化调用顺序：1）基类构造器。2）按声明顺序调用成员变量的初始化方法。3）调用导出类的构造器。
22、销毁顺序与初始化顺序相反。
23、编写构造器时，用尽可能简单的方法使对象进入正常状态。如果可以的话，避免调用其他方法。在构造器内唯一能够安全调用的那些方法是基类中的final方法（这些方法不能被覆盖）。
24、协变返回类型：导出类中被覆盖的方法可以返回基类方法返回类型的某种导出类型。
25、interface的域是隐式的staic和fianl。方法都是public。
26、java的多接口implements设计，便于能够向上转型为多个基类型（以及由此带来的灵活性）。
27、接收接口类型的方法，可以增加方法的灵活性、通用性和可复用性。例如Java SE5中Scanner的构造器接收一个Readable的参数。
28、接口嵌套：接口中的元素依旧都是public。
29、当实现某个接口时，并不需要实现嵌套在其内部的任何接口。且private接口不能在定义它的类外被实现。
30、内部类的对象能够访问制造它的外围对象的所有成员。内部类拥有其外围类的所有元素的访问权，因为隐式地保存了一个引用。如果内部类声明为static，则变成嵌套类，丧失了与其外围类对象之间的关系。
31、如果需要生成对外部对象的引用。可以使用外部类的名字后面紧跟“.this”。这样产生的引用自动地具有正确的类型（编译期检查，没有运行时开销）。
32、若想告知其他对象去创建其某个内部类的对象。必须在new表达式中提供对其他外部类对象的引用（使用“.new”的语法）。
33、定义在作用域的类（此作用域在方法的内部。例如if的分支中）并不是有在作用域才创建，而是与其它类一起编译。
34、如果定义一个匿名内部类，并且希望它使用一个在其外部定义对象，那么编译器会要求其参数引用是fianl。
35、1）创建嵌套类的对象，不需要其外围类的对象。2）不能从嵌套类的对象中访问非静态的外围类对象。
36、【接口嵌套类的使用场景？】如果想创建某些公共代码，使得它们可以被某个接口的所有实现所公用，那么使用接口内部的嵌套类会显得很方便。
37、继承内部类时，导出类必须生成一个构造器，构造器入参必须包括外围类对象的引用。并且必须在构造器内调用“外围对象.super()”。
38、当外围类A继承外围类B时，A的内部类C并不会覆盖B中同名的内部类C。A的内部类C和B的内部类C是完全独立的两个实体，各自在自己的命名空间内。
39、匿名内部类只能用于实例初始化。局部内部类包含已命名的构造器，可以重载构造器。
40、内部类的.class文件命名规则：1）外围类的名字，加上“$”，再加上内部类的名字。2）如果内部类是匿名的，编译器会生成一个数字作为其标识符。3）内部类的内部类，只需在后面追加“$”内部类的名字。
41、Arrays.toString(array)用于数组打印。但容器提供的toString()即可以产生阅读性良好的打印结果。
42、Arrays.asList()其底层仍然是数组，因此不能调整大小。运行时调用add()或者delete()会产生“Unsupported Operation”。
43、LinkedHashMap按照插入顺序保存键，并保留了HashMap的查询速度。
44、ArrayList随机访问效率较高，但是在List的中间插入和移除元素时较慢。LinkedList相反。
45、List的contains()、remove()、add()、retainAll()（取交集操作）都会调用equals()。
46、List的set(index, object)用object替换index处的元素。
47、ListIterator是Iterator的子类型，提供了比Iterator更加强大的功能。Iterator只能向前移动，ListIterator可以双向移动。调用listIterator(n)创建一个一开始就指向列表索引为n的元素处的Iterator。
48、LinkedList中getFirst()、element()完全一样，它们都返回列表的头（第一个元素），而并不移除它，如果List为空，则抛出NoSuchElementException。peek()与这两个方式只是稍有差异，它在列表为空时返回null。
49、removeFirst()与remove()完全一样，它们移除并返回列表的头。如果List为空，则抛出NoSuchElementException。poll()在列表为空时返回null。
50、addFirst()与add()和addList()相同，它们都将某个元素插入到列表的尾部。
51、类名之后的<T>会告诉编译器这将是一个参数化类型，而其中的类型参数，即在类被使用时将会被实际类型替换的参数，就是T。
52、native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。
53、foreach可以运用于所有实现Iterable的接口的类。Iterable的iterator()用于产生并返回Iterator，并且Iterable接口foreach用来在序列中移动。
54、System.getenv()获得操作系统相关信息。
55、Arrays.asList()产生的List对象会使用底层数组作为其物理实现，操作该List对象将会改变原始数组。如果不想改变原始数组，使用另一个容器创建一个副本。List<T> list = new ArrayList(Arrays.asList())。
56、容器不能持有基本类型，但是自动包装机制会仔细地执行基本类型到容器中所持有的包装器类型之间的双向转换。
57、catch(Exception e){throw e}.如果把当前异常对象重新抛出，printStackTrace()方法显示的是原来异常抛出点的调用栈信息，而非重新抛出点的信息。要更新这个信息，可以调用fillInStackTrac()方法，这将返回一个Throwable对象。它是通过将当前调用栈信息填入原来那个异常对象而建立的。
58、Throwable的子类中只有Error、Exception、RuntimeException提供了带cause参数的构造器。以形成异常链（捕获一个异常后抛出另一个异常，并保存原始异常的信息）。其它Throwable的子类应该使用initCause()方法。
58、initCause()方法就是对异常来进行包装的，目的就是为了出了问题的时候能够追根究底。返回统一异常，并保留最原始的异常信息。
59、RuntimeException（及其子类）不需要在异常说明中声明方法将其抛出。
60、在继承、覆盖过程中，导出类的特定方法的异常说明不能比基类多。构造器相反。
61、String的“+”、“+=”是Java中仅有的两个重载的操作符，并且java不允许程序员重载操作符。
62、String对象是不可变的，String类中每一个看起来会修改String值的方法，实际上是创建了一个全新的String对象。而最初的String对象并没有改变。
63、JDK自带反编译工具javap（javap -c 类名）。
64、如果循环连接字符串，使用StringBuild的append()效率更高。
65、printf()、System.out.format()、Formatter类、String.format()用于格式化输出数据。
66、Matcher对象相关方法：matches()判断输入字符串是否匹配正则模式。lookingAt()判断字符串的起始部分是否匹配正则模式。find()查找多个匹配。
67、组（Groups），组是用括号划分的正则表达式，可以根据组的编号引用某个组。组号为0表示整个表达式，组号1表示被第一对括号括起的组，以此类推。
68、使用reset()方法，可以将现有的Matcher对象应用于一个新的字符序列。
69、Scanner可以使用useDelimiter()设定定界符。
70、所有的类都是在对其第一次使用时，动态加载到JVM中。
71、Class.forName()需使用全限定名（包含报名）。Class对象相关方法：getName()、isInterface()、getSimpleName()、getCanonicalName()、getInterfaces()、getSuperclass()。
72、类字面常量：类名.class。
73、使用“类字面常量”来创建Class对象的引用时，不会自动地初始化该Class对象。而Class.forName()立即进入初始化。
74、如果使用泛型语法用于Class对象（Class<具体类>），newInstance()将返回该对象的具体类型。如果不使用泛型语法，则返回Object。
75、如果使用超类，编译器不接受Class<A> a = bClass.getSuperclass();的声明，只能使用Class<? super B> a = bClass.getSuperclass();。（B extends A，Class<B> bClass = B.class;）
76、Proxy的public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException用于创建动态代理。
77、static方法无法访问泛型类的类型参数，如果static方法需要使用泛型能力，就必须成为泛型方法。定义泛型方法，只需要将泛型参数列表置于返回值之前。使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型，这称为“类型参数推断”。在泛型方法中，可以显式地指明类型，不过这种语法很少使用。要显式地指明类型，必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内。如果在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static的方法，必须在点操作符之前加上类名。
78、泛型中的类型判断只对赋值操作有效，其他时候并不起作用。
79、java泛型是使用擦除来实现的，这意味着但你在使用泛型时，任何具体的类型信息都被擦出了，因此List<String>和List<Interger>在运行时事实上是相同的类型。这两种形式都被擦除成它们的“原生”类型，即List。
80、运用擦除的主要原因是从非泛化代码转到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入java语言。
81、在泛型中创建数组，建议使用Array.newIntance()，并传递Class信息，以便从擦除中恢复。
82、所有在泛型的所有动作都发生在边界处——对传递进来的值进行额外的编译期检查，并对传递出去的值进行转型。
83、可以使用显示地传递类型的Class对象，补偿擦除的的类型信息。
84、与数组不同，泛型没有內建的协变类型。
85、编译器处理List<?>和List<? extends Object>是不同的。
86、List实际上表示“持有任何Object类型的原生List”，而List<?>表示“具有某种特定类型的非原生List”。
87、自动包装机制不能应用于数组。
88、一个类不能实现同一个泛型接口的两种变体。由于擦除的原因，这两个变体会成为相同的接口。
89、可以使用“A.class.cast(B)”进行转型（通过泛型类进行转型）。
90、可以使用java.util.Collections中的checkedCollection()、checkedList()、checkedMap()、checkedSet()、checkedSortedMap()、checkedSortedSet()构造可以动态检查的容器。在插入的时候就进行检查，而不是取出的时候才知道问题（不容易追溯源头）。这种问题常出现于，使用Java5（有泛型）之前的代码方法参数使用原生容器，而调用时传入泛型容器。例如：List<A> list = Collections.checkedList(new ArrayList<A>, A.class);
91、混型：一个类获取多个类的能力。
92、潜在类型机制（Java使用反射进行实现）：潜在类型机制是一种代码组织和复用机制，当用某个实例调用方法时，它只要求实现该实例实现了这些方法子集，而不用继承或实现某个接口，换句话说，程序不关心你什么类型，只要你的类型带有这些方法就行了，这样满足你可以横跨类继承结构，而调用不属于某个公共接口的方法。
