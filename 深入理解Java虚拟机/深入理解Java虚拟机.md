# 1 走进 java

## 1.2 java 技术体系

​	JDK （ Java Development Kit ）包括 Java 程序设计语言、 Java API 类库和 Java 虚拟机。 JDK 是用于支持 Java 程序开发的最小环境。

​	JRE（ Java Runtime Environment ）包括 Java API 类库中的 Java SE API 子集和 Java 虚拟机， JRE 是支持 Java 程序运行的标准环境。

## 1.4 java 虚拟机发展史

### 1.4.2 Sun HotSpot VM

​	HotSpot VM  的热点代码检测能力可以通过执行计数器找出最有编译价值的代码，然后通知 JIT 编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中训话次数很多，将会分别触发标准编译和 OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。

## 1.6 实战：自己编译 jdk

### 1.6.1 获取 JDK 源码

​	OpenJDK 是 Sun在2006年末把 Java 开源而形成的项目。Sun 自 JDK 1.5 之后就开始以 Java Research License （JRL）的形式公布过 Java 源码。把 这些 JRL 许可证形式的 Sun/OracleJDK 源码和对应版本的 OpenJDK 源码进行比较，发现除了文件头的版权注释之外，其余代码基本上都是相同的，只有字体渲染部分存在一点差异。 Oracle JDK 中还会存在一些 Open JDK 没有的、商用闭源的功能，例如从 JRockit 移植改造而来的 Java Flight Recorder 。

# 2 Java 内存区域与内存溢出异常

​	Java 虚拟机所管理的内存将会包括以下几个运行时数据区域。

![Java虚拟机运行时数据区](resources/Java虚拟机运行时数据区.png)

### 2.2.1 程序计数器

​	程序技术器（ Program Counter Register ） 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。

​	由于 Java 虚拟机的多线程是通过线程轮流切换并奉陪处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的命令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

​	如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数值则为空（ Undefined ）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### 2.2.2 Java 虚拟机栈

​	与程序计数器一样， Java 虚拟机栈（ Java Virtual Machine Stacks ）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时会创建一个栈帧（ Stack Frame ）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法总调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。

​	局部变量表存放了编译期可知的各种基本数据类型（ boolean 、 byte 、 char 、 short 、 int 、 float 、 long 、 double ）、对象引用（ reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是执行一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。

​	其中 64 位长度的 long 和 double 类型的数据会占用2个局部变量空间（ Slot ），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

​	在 Java 虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常：如果虚拟机栈可以动态扩展（当前大部分 Java 虚拟机都可以动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。

### 2.2.3 本地方法栈

​	本地方法栈（ Native Method Stack ）与虚拟机栈所返回的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法则为虚拟机使用到的 Native 方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机栈可以自由实现它。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。

### 2.2.4 Java 堆

​	Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。所有的对象实例以及数组都要在堆上分配，但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不那么“绝对”了。

​	Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称作“ GC 堆”。从内存分配的角度来看，线程共享的 Java 堆可能划分出多个线程私有的分配缓冲区（ Thread Local Allocation Buffer ， TLAB ）。

​	Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 ``-Xmx`` 和 ``-Xms`` 控制）。

### 2.2.5 方法区

​	方法区（ Method Area ）是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做 Non-Heap （非堆），目的应该是与 Java 对区分开来。

​	这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

### 2.2.6 运行时常量池

​	运行时常量池（ Runtime Constant Pool ）是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（ Constant Pool Table ），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

​	Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被利用得比较多的便是 String 类的 intern() 方法。

> 1. 直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。
>
> 2. new出来的字符串是存放在堆里面。
>
> 3. 对字符串进行拼接操作，也就是做"+"运算的时候，分2种情况：
>
>    i.表达式右边是纯字符串常量，那么存放在栈里面。
>
>    ii.表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面。
>
>    String 的 intern() 把字符串对象加入常量池中。

### 2.2.7 直接内存

​	直接内存（ Direct Memory ）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。

​	在 JDK 1.4 中新加入了 NIO 类，引入了一种基于通道（ Channel ）与缓冲区（ Buffer ）的 I/O 方式，它可以使用 Native 函数库直接分配对外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为该块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

## 2.3 HotSpot 虚拟机对象探秘

### 2.3.1 对象的创建

​	虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，那必须先执行相应的类加载过程。

​	在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存大小在类加载完成后便可完全确定。

​	假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把那个指针向空闲空间那边挪动一端与对象大小相等的距离，这种分配方式称为“指针碰撞”（ Bump the Pointer ）。

​	如果 Java 堆中的内存并不是规整的，已使用的内存和空间的内存相互交错，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（ Free List ）。

​	选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial 、 ParNew 等带 Compact 过程的收集器是，系统采用的分配算法是指针碰撞，而使用  CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。

​	除如何划分可用空间之外，还有另一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅一个修改指针所指向的位置，在并发情况下也并不是线程安全的。解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（ Thread Local Allocation Buffer , TLAB ）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。虚拟机是否使用 TLAB ，可以通过 `` -XX:+/-UseTLAB``参数来设定。

​	内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB ，这一工作也可以提前至 TLAB 分配时进行。这一步操作保证了对象的实例字段在 Java 代码中不赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。

​	接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头（ Object Header ）之中。根据虚拟机当前的运行状态不同，如是否有偏向锁等，对象头会有不同的设置方式。

​	上面工作都完成后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，一般来说（由字节码中是否跟随 invokespecial 指令所决定），执行 new 指令之后会接着执行\< init \>方法。

### 2.3.2 对象的内存布局

​	在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（ Header ）、实例数据（ Instance Data ）和对齐填充（ Padding ）。

​	HotSpot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（ HashCode ）、 GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID 、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32 bit 和64 bit ，官方称它为“ Mark Word ”。对象需要存储的运行时数据很多，其实已经超出了32位、64位 Bitmap 结构所能记录的限度， Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的 Hotspot 虚拟机中，如果对象处于未被锁定的状态下，那么 Mark Word 的32 bit 空间中的25 bit 用于存储对象哈希码，4 bit 用于存储对象分代年龄，2 bit 用于存储锁标志位，1 bit 固定为0，而在其他状态（轻量级锁定、重量级锁定、 GC 标记、可偏向）下对象的存储内容如下。

![Hotspot 虚拟机对象头](resources/MarkWord.png)

​	对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，话句话说，查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是一个数组，还必须有一块用于记录数组长度的数据。

​	无论是从父类集成下来的，还是在子类中定义的，在程序代码中所定义的各种类型的字段内容，都需要记录下来。这部分的存储顺序会受到虚拟机分配策略参数（ FiledsAllocationStyle ）和字段在 Java 源码中定义顺序的影响。 Hotspot 虚拟机默认的分配策略为 longs/doubles 、ints 、 shorts/chars 、bytes/booleans 、 oops （ Ordinary Object Pointers ），从分配策略可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFileds 参数值为 true （默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。

​	第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 Hotspot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。而对象头正好是8字节的整数倍，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

### 2.3.3 对象的访问定位

​	通过何种方式定位、访问堆中对象的具体位置，取决于虚拟机的实现而定的。目前主流的访问方式由使用句柄和直接指针两种。

- 如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池， reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示。

![句柄方式访问对象](resources/句柄方式访问对象.jpg)

- 如果使用直接指针访问，那么 Java 堆对象的布局就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址，如下图所示。

  ![直接指针方式访问对象](resources/直接指针方式访问对象.jpg)

​	使用句柄的最大好处就是 reference 中存储的稳定的句柄地址，在对象被移动（垃圾收集时，移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。

​	使用直接指针访问方式的最大好处就是速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 Sun HotSpot 使用第二种防护四进行对象访问。

### 2.4 实战 OutMemoryError 异常

### 2.4.2 虚拟机栈和本地方法栈溢出

​	操作系统分配给每个进程的内存是有限制的，譬如 32 位的 Windows 限制为 2 GB 。剩余的内存为 2 GB （操作系统限制）减去 Xmx （最大堆容量），再减去 MaxPermSize （最大方法区容量），程序计数器小号内存很小，可以忽略掉。如果虚拟机进程本身消耗的内存不计算在内，剩下的内存就有虚拟机栈和本地方法栈“瓜分”了。

​	如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换 64 位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。

### 2.4.3 方法区和运行时常量池溢出

​	当前的很多主流框架，如 Spring 、 Hibernate ，在对类进行增强是，都会使用到 CGLib 这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的 Class 可以加载入内存。另外， JVM 上的动态语言（如 Groovy 等）通常都会持续创建类来实现动态语言的特性。

​	方法区溢出是一种常见的溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量 Class 的应用中，需要特别注意类的惠州状况。这类场景除了 CGLib 字节码增强和动态语言之外，常见的还有：大量 JSP 或动态产生 JSP文件多的应用（ JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 的应用（即使是同一个类文件，被不同的加载器加载也会被视为不同的类）等。

### 2.4.4 本机直接内存溢出

​	DirectMemory 容量可以通过 -XX ：MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆最大值（ -Xms 指定）一样，下面的代码通过 DirectByteBuffer 类，直接通过反射获取 Unsafe 实例进行内存分配（ Unsafe 类的 getUnsafe() 方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有 rt.jar 中的类才能使用 Unsafe 的功能）。因为，虽然使用 DirectByteBuffer 分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是 unsafe.allocateMemory() 。

``` java
public class DirectMemoryOOM {

    private static final int _1MB = 1024 * 1024;

    public static void main(String[] args) throws Exception {
        Field unsafeField = Unsafe.class.getDeclaredFields()[0];
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);
        while (true) {
            unsafe.allocateMemory(_1MB);
        }
    }
}
```

​	通过 DirectMemory 导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，可以考虑检查一下是不是这方面的原因。

# 3 垃圾收集器与内存分配策略

## 3.1 引用计数算法

​	主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，其中主要的原因是它很难解决对象之间互相循环引用的问题。

## 3.2 可达性分析算法

 	算法的基本思路是通过一系列称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称之为”引用链（ Reference Chain ）”，当一个对象到 GC Roots 没有任何的引用链相连时(从GC Roots到这个对象不可达)时，证明此对象是不可用的。

![可达性分析算法判断对象是否可回收](resources/可达性分析算法.jpg)

​	在 Java 语言中，可作为 GC Roots 的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法中 JNI（即一般说的 Native 方法）引用的对象。

​	 Java 从 JDK 1.2版本之后，把对象的引用分为四种级别：强引用（ Strong Reference ）、软引用（ Soft Reference ）、弱引用（ Weak Reference ）和虚引用（ Phantom Reference ）。这4种引用强度依次逐渐减弱。

- 强引用就是指在程序代码之中普遍存在的，类似“ Object obj = new Object() ”这类的引用，只要强引用还存在，垃圾器永远不会回收掉被引用的对象。

- 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2之后，提供了 SoftReference 类来实现软引用。这一点可以很好地用来解决 OOM 问题，这个特性适合用来实现缓存：比如网页缓存、图片缓存等。

  ```java
  Browser prev = new Browser();// 获取页面进行浏览
  SoftReference<Browser> sr = new SoftReference<>(prev);// 浏览完毕后置为软引用
  if (sr.get() != null) {
      rev = sr.get();// 未被回收器回收，直接获取
  } else {
      prev = new Browser();// 内存不足时，软引用对象已被回收。重新构建。
      sr = new SoftReference<>(prev);
  }
  ```

- 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收发生之前，当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2之后，提供了 WeakReference 类来实现弱引用。由于，垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

- 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2之后，提供了 PhantomReference 类来实现虚引用。

  | 引用类型   | 用途           | 被回收时间 | 生存时间          |
  | ---------- | -------------- | ---------- | ----------------- |
  | **强引用** | 对象的一般状态 | 从来不会   | JVM停止运行时终止 |
  | **软引用** | 对象缓存       | 内存不足   | 内存不足时终止    |
  | **弱引用** | 对象缓存       | 垃圾回收   | GC运行后终止      |
  | **虚引用** | unknow         | unknow     | unknow            |

### 3.2.4 生存还是死亡

​	即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

​	如果这个对象被判定有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致 F-Queue 队列中其他对象永久等待，甚至导致整个内存会后系统崩溃。 finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记。

​	finalize() 不是 C/C++ 中的析构函数，而是 Java 刚诞生时为了使 C/C++ 程序员更容易接受它所作出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。

### 3.2.5 回收方法区

​	方法区（或者 HotSpot 虚拟机中的永久代）中进行垃圾收集的“性价比”一般比较低。

​	永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，没有任何 String 对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。

​	判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。

- 加载该类的 ClassLoader 已经被回收。

- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

​	虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收， HotSpot 虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceClassLoading 、 -XX:+TraceClassUnLoading 查看类加载和卸载信息，其中  -verbose:class 和 -XX:+TraceClassLoading 可以在 Product 版的虚拟机中使用， -XX:+TraceClassUnLoading 参数需要 FastDebug 版的虚拟机支持。

## 3.3 垃圾收集算法

### 3.3.1 标记-清除算法

![标记-清除算法](resources/标记-清除算法.jpg)

​	最基础的收集算法是“标记-清除”（ Mark-Sweep ）算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的不足主要有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![标记-清除算法2](resources/标记-清除算法2.jpg)

### 3.3.2 复制算法

![复制算法](resources/复制算法.jpg)

​	“复制”（ Copying ）算法，解决了效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要一动堆顶指针，按顺序分配内存即可，实现简单，运行高效。代价是将内存缩小为原来的一半。

![复制算法2](resources/复制算法2.jpg)

​	现在商业虚拟机都采用这种收集算法来回收新生代， IBM 公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 空间。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用过的 Survivor 空间。 Hotspot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1。当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（ Handle Promotion ）。

### 3.3.3 标记-整理算法

![标记-整理算法](resources/标记-整理算法.jpg)

​	老年代一般不能直接使用复制收集算法。

​	标记过程与“标记-清除”算法一样，后续让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

![标记-整理算法2](resources/标记-整理算法2.jpg)

### 3.3.4 分代收集算法

​	在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法进行回收。

## 3.4 HotSpot 的算法实现

### 3.4.1 枚举根节点

​	可达性分析对执行时间的敏感体现在 GC 停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里的“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果就无法得到保证。这点是导致 GC 进行时必须停顿所有 Java 执行线程的其中一个重要原因。

​	目前的主流 Java 虚拟机使用的都是准确式 GC ，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象的引用。在 HotSpot 的实现中，是使用一组称为 OopMap 的数据结构来达到这个目的，在类加载完成的时候， HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样， GC 在扫描时就可以直接得知这些信息了。

### 3.4.2 安全点

​	HotSpot 没有为每条指令都生成 OopMap ，只是在“特定的位置”记录了这些信息，这些位置称为安全点（ Safepoint ），即程序执行时并非在所有地方都能停顿下来开始 GC ，只有在到达安全点事才能暂停。安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生 Safepoint 。

​	抢先式中断（ Preemptive Suspension ）：不需要线程的执行代码主动配合，在 GC 发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应 GC 事件。

​	主动式中断（Voluntary Suspension ）：当 GC 需要中断的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

### 3.4.3 安全区域

​	安全区域（ Safe Region ）是指一段代码片段之中，引用关系不会发生变化。在这个区域中的任何地方开始 GC 都是安全的，可以把 Safe Region 看做是被拓展了的 Safepoint 。

​	在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region ，当在这段时间里 JVM 要发起  GC 时，就不用管标识自己为 Safe Region 状态的线程了。在线程要离开 Safe Region 时，它要检查系统是否已经完成了根节点枚举（或者是整个 GC 过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止。

## 3.5 垃圾收集器

![HotSpot 虚拟机的垃圾收集器](resources/HotSpot虚拟机的垃圾收集器.png)

​	上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。

### 3.5.1 Serial 收集器

![SerialAndSerialOld收集器运行示意图](resources/SerialAndSerialOld收集器运行示意图.png)

​	Serial 收集器是最基本、发展历史最悠久的收集器，曾经（在 JDK 1.3.1 之前）是虚拟机新生代收集的唯一选择。在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。

### 3.5.2 ParNew 收集器

![ParNewSerialOld收集器运行示意图](resources/ParNewSerialOld收集器运行示意图.png)

​	ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数（例如： -XX:SurvivorRatio 、-XX:PretenureSizeThreshold 、 -XX:HandlePromotionFailure 等）、收集算法、 Stop The World 、对象分配规则、回收策略等都与 Serial 收集器完全一样。

​	它是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中一个与性能无关的重要原因是，除了 Serial 收集器外，目前只有它能与 CMS （ Concurrent Mark Sweep ）收集器配合工作。

​	ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至优于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。随着可以使用的 CPU 的数量的增加，它对于 GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多的环境下，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。

>在垃圾收集器的上下文语境中，将并发和并行，做专门解释。
>
>- 并行（ Parallel ）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
>- 并发（ Concurrent ）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行在另一个 CPU 上。

### 3.5.3 Parallel Scavenge 收集器

​	Parallel Scavenage 收集器的目标是达到一个可控制的吞吐量。所谓吞吐量就是 CPU 用于运行客户代码的时间与 CPU 总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。

​	停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

​	Parallel Scavenage 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数。

​	MaxGCPauseMillis 参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不要以为如果把这个参数设置得稍小一点就能使得系统的垃圾收集速度变得更快， GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的。

​	 -XX:GCTimeRatio 参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大 GC 时间就占总时间的5%（即1/(1+19)），默认值为99，就是允许最大1%（即1/（1+99））的垃圾收集时间。

​	Parallel Scavenage 收集器也经常称为“吞吐量优先”收集器。Parallel Scavenage 收集器还有一个参数 -XX:UseAdaptiveSizePolicy ，这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（ -Xmn ）、 Eden 与 Survivor 区的比例（ -XX:SurvivorRatio ）、晋升老年代对象年龄（ -XX:PretenureSizeThreshold ）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。

### 3.5.4 Serial Old 收集器

​	Serial Old 收集器是 Serial 收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意思也是在于给 Client 模式下的虚拟机使用。如果在 Server 模式下，那么它主要还有两大用途：一种用途是在 JDK 1.5 以及以前的版本中与 Parallel Scavenage 收集器搭配使用，另一种用途就是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

### 3.5.5 Parallel Old 收集器

​	Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenage 加 Parallel Old 收集器。

![ParallelScavengeParallelOld收集器运行示意图](resources/ParallelScavengeParallelOld收集器运行示意图.png)

### 3.5.6 CMS 收集器

​	CMS（ Concurrent Mark Sweep ）收集器是以一种获取最短回收停顿时间为目标的收集器。

​	CMS 收集器是基于“标记——清除”算法实现的，整个过程分为4个步骤：

- 初始标记（ CMS initial mark ）

- 并发标记（ CMS concurrent mark ）

- 重新标记（ CMS remark ）

- 并发清除（ CMS concurrent sweep ）

  初始标记、重新标记这两个步骤需要“ Stop The World ”。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行 GC Roots Tracing 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会比初始标记阶段稍长一些，但远比并发标记时间短。

![CMS收集器运行示意图](resources/CMS收集器运行示意图.png)

​	CMS 有以下3个明显的缺点：

- CMS 收集器对 CPU 资源非常敏感。 CMS 默认启动的回收线程数是（ CPU 数量+3）/4，也就是当 CPU 在4个以上时，并发回收时垃圾收集线程不少于25%的 CPU 资源，并且随着 CPU 数量的增加而下降。
- CMS 无法处理浮动垃圾，可能出现“ Concurrent Mode Failure ”失败而导致另一次 Full GC 产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，着一部分垃圾出现在标记过程之后， CMS 无法再档次收集中处理掉它们，只要等待下一次 FC 时再清理掉。这一部分垃圾就称为“浮动垃圾”。 CMS 收集器需要预留一部分空间提供并发收集时的程序运作使用。在 JDK 1.5 的默认设置下， CMS 收集器当老年代使用了 68% 的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是很快，可以适当调高参数 -XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在 JDK 1.6 中， CMS 收集器的启动阈值已经提升至92%。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“ Concurrent Mode Failure ”失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数 -XX:CMSInitiatingOccupancyFraction 设置得太高很容易导致大量“ Concurrent Mode Failure ”失败，性能反而降低。
- 收集结束时，会有大量空间碎片产生。 CMS 收集器提供了一个 -XX:+UseCMSCompactAtFullCollection 开关参数（默认是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction ，这个参数用于设置执行多少次不压缩的 Full GC 后，跟着来一次带压缩的（默认值为0，表示每次进入 Full GC 时都进行碎片整理）

### 3.5.7 G1 收集器

​	G1 特点：

- 并行与并发
- 分代收集
- 空间整合
- 可预测的停顿：能让使用者明确再也一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。

​	G1 收集器将整个 Java 堆划分为多个大小相等的独立区域（ Region ），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region （不需要连续）的集合。

​	G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行安全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region 。这种使用 Region 划分内存空间以及优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。

​	在 G1 收集器中， Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用 Remembered Set 来避免全堆扫描的。 G1 中每个 Region 都有一个与之对应的 Remembered Set ，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Writer Barrier 暂时中断写操作，检查 Reference 引用对象是否处于不同的 Region 之中，如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。

​	如果不计算维护 Remembered Set 的操作， G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记（ Initial Marking）

- 并发标记（ Concurrent Marking ）

- 最终标记（ Fianl Marking ）

- 筛选回收（ Live Data Counting and Evacuation ）

​	初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS （ Next Top at Mark Start ）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这个阶段需要停顿线程，但耗时很短。

​	并发标记阶段是从 GC Root 开始对堆对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。

​	最终标记阶段则是为了修正在并发标记期间因用户陈旭继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这个阶段需要停顿线程，但是可并行执行。

​	筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。

![G1收集器运行示意图.png](resources/G1收集器运行示意图.png)

### 3.5.8 理解 GC 日志

​	每个收集器的日志格式可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的 GC 日志：

> 33.125：[ GC [ DefNew : 3324k->152k(3712k), 0.0025925 secs ] 3324k->152k(11904K),0.0031680 secs ]
>
> 100.667：\[ Full GC [ Tenured：0K-＞210K(10240K)，0.0149142 secs ] 4603K-＞ 210K(19456K)，\[ Perm：2999K-＞2999K(21248K)]，0.0150007 secs][Times：user=0.01 sys=0.00，real=0.02 secs]

​	最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。

​	GC 日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型。如果有“Full”，说明这次 GC 是发生了 Stop-The-World 的，例如下面这段新生代收集器 ParNew 的日志也会出现“[Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致 STW ）。如果是调用 System.gc() 方法所触发的收集，那么在这里将显示“[ Full GC ( System )”。

> [Full GC 283.736：[ParNew：261599K-＞261599K（261952K），0.0000288 secs]

​	接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“[DefNew”。

​	后面方括号内部的“3324K-＞152K（3712K）”含义是“GC前该内存区域已使用容量-＞GC后该内存区域已使用容量（该内存区域总容量）”。 
而在方括号之外的“3324K-＞152K（11904K）”表示“GC前Java堆已使用容量-＞GC后Java堆已使用容量（Java堆总容量）”。

​	再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。

​	有的收集器会给出更具体的时间数据，如“[Times：user=0.01 sys=0.00，real=0.02 secs]”，这里面的 user 、 sys 和 real 与 Linux 的 time 命令所输出的时间含义一致，分别代表用户态消耗的 CPU 时间、内核态消耗的 CPU 事件和操作从开始到结束所经过的墙钟时间（ Wall Clock Time ）。

​	CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘 I/O 、等待线程阻塞，而 CPU 时间不包括这些耗时，但当系统有多 CPU 或者多核的话，多线程操作会叠加这些 CPU 时间，所以 user 或 sys 时间超过 real 时间是完全正常的。

| 参　　数                                                     | 描　　述                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| UseSerialGC                                                  | 虚拟机运行在 Client 模式下的默认值，打开此开关后，使用 Serial + Serial Old 的收集器组合进行内存回收 |
| UseParNewGC                                                  | 打开此开关后，使用 ParNew + Serial Old 的收集器组合进行内存回收 |
| UseConcMarkSweepGC                                           | 打开此开关后，使用 ParNew + CMS + Serial Old 的收集器组合进行内存回收。 Serial Old 收集器将作为 CMS 收集器出现 Concurrent Mode Failure 失败后的后备收集器使用 |                                                              |
| UseParallelGC                                                | 虚拟机运行在 Server 模式下的默认值，打开此开关后，使用 Parallel Scavenge + Serial Old（PS MarkSweep）的收集器组合进行内存回收 |
| UseParallelOldGC                                             | 打开此开关后，使用 Parallel Scavenge + Parallel Old 的收集器组合进行内存回收 |
| SurvivorRatio                                                | 新生代中 Eden 区域与 Survivor 区域的容量比值， 默认为8， 代表 Eden ：Survivor =8∶1 |
| PretenureSizeThreshold                                       | 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 |
| MaxTenuringThreshold                                         | 晋升到老年代的对象年龄。每个对象在坚持过一次 Minor GC 之后，年龄就加1，当超过这个参数值时就进入老年代 |
| UseAdaptiveSizePolicy                                        | 动态调整 Java 堆中各个区域的大小以及进入老年代的年龄         |
| HandlePromotionFailure                                       | 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个 Eden 和 Survivor 区的所有对象都存活的极端情况 |
| ParallelGCThreads                                            | 设置并行 GC 时进行内存回收的线程数                           |
| GCTimeRatio                                                  | GC 时间占总时间的比率，默认值为99，即允许1% 的 GC 时间。仅在使用 Parallel Scavenge 收集器时生效 |
| MaxGCPauseMillis                                             | 设置 GC 的最大停顿时间。仅在使用 Parallel Scavenge 收集器时生效 |
| CMSInitiatingOccupancyFraction                               | 设置 CMS 收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用 CMS 收集器时生效 |
|UseCMSCompactAtFullCollection|设置 CMS 收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用 CMS 收集器时生效|
|CMSFullGCsBeforeCompaction|设置 CMS 收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用 CMS 收集器时生效|

## 3.6 内存分配与回收策略

​	对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。

### 3.6.1 对象优先在 Eden 分配

​	大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor  GC 。

> - 新生代 GC （ Minor GC ）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较块。
>
> - 老年代 GC （ Major GC / Full GC ）：指发生在老年代的 GC ，出现了 Major GC ，经常会伴随至少一次的 Minor GC （但非绝对的，在 Parallel Scavenge 收集器的收集策略里就直接进行 Major GC 的策略选择过程）。 Major GC 的速度一般会比 Minor GC 慢 10 倍以上。

### 3.6.2 大对象直接进入老年代

​	所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值得对象直接在老年代分配。避免在 Eden 区以及两个 Survivor 区之间发生大量的内存复制。

> PretenureSizeThreshold 参数只针对 Serial 和 ParNew 两款收集器有效， Parallel Scavenge 收集器不认识这个参数， Parallel Scavenge 收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑 ParNew 和 CMS 的收集器组合。

### 3.6.3 长期存活的对象将进入老年代

​	虚拟机采用了分代收集的思想管理内存。虚拟机给每个对象定义了一个对象年龄计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的haul，将被移动到 Survivor 空间中，并且对象年龄设为1。对象在 Survivor 区中每“熬过”一次 Minor GC ，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 设置。

### 3.6.4 动态对象年龄判定

​	为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。

### 3.6.5 空间分配担保

​	在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试这进行一次 Minor GC ，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC 。

​	在 JDK 6 Update 24 之后， HandlePromotionFailure 参数不会影响到虚拟机的空间分配担保策略，虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它。 JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC ，否则将进行 Full GC 。

