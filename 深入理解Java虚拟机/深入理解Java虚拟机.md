#1 走进 java

## 1.2 java 技术体系

​	JDK （ Java Development Kit ）包括 Java 程序设计语言、 Java API 类库和 Java 虚拟机。 JDK 是用于支持 Java 程序开发的最小环境。

​	JRE（ Java Runtime Environment ）包括 Java API 类库中的 Java SE API 子集和 Java 虚拟机， JRE 是支持 Java 程序运行的标准环境。

## 1.4 java 虚拟机发展史

### 1.4.2 Sun HotSpot VM

​	HotSpot VM  的热点代码检测能力可以通过执行计数器找出最有编译价值的代码，然后通知 JIT 编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中训话次数很多，将会分别触发标准编译和 OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。

## 1.6 实战：自己编译 jdk

### 1.6.1 获取 JDK 源码

​	OpenJDK 是 Sun在2006年末把 Java 开源而形成的项目。Sun 自 JDK 1.5 之后就开始以 Java Research License （JRL）的形式公布过 Java 源码。把 这些 JRL 许可证形式的 Sun/OracleJDK 源码和对应版本的 OpenJDK 源码进行比较，发现除了文件头的版权注释之外，其余代码基本上都是相同的，只有字体渲染部分存在一点差异。 Oracle JDK 中还会存在一些 Open JDK 没有的、商用闭源的功能，例如从 JRockit 移植改造而来的 Java Flight Recorder 。

# 2 Java 内存区域与内存溢出异常

​	Java 虚拟机所管理的内存将会包括以下几个运行时数据区域。

![Java虚拟机运行时数据区](resources\Java虚拟机运行时数据区.png)

### 2.2.1 程序计数器

​	程序技术器（ Program Counter Register ） 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。

​	由于 Java 虚拟机的多线程是通过线程轮流切换并奉陪处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的命令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

​	如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数值则为空（ Undefined ）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### 2.2.2 Java 虚拟机栈

​	与程序计数器一样， Java 虚拟机栈（ Java Virtual Machine Stacks ）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时会创建一个栈帧（ Stack Frame ）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法总调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。

​	局部变量表存放了编译期可知的各种基本数据类型（ boolean 、 byte 、 char 、 short 、 int 、 float 、 long 、 double ）、对象引用（ reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是执行一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。

​	其中 64 位长度的 long 和 double 类型的数据会占用2个局部变量空间（ Slot ），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

​	在 Java 虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常：如果虚拟机栈可以动态扩展（当前大部分 Java 虚拟机都可以动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。

### 2.2.3 本地方法栈

​	本地方法栈（ Native Method Stack ）与虚拟机栈所返回的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法则为虚拟机使用到的 Native 方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机栈可以自由实现它。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。

### 2.2.4 Java 堆

​	Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。所有的对象实例以及数组都要在堆上分配，但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不那么“绝对”了。

​	Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称作“ GC 堆”。从内存分配的角度来看，线程共享的 Java 堆可能划分出多个线程私有的分配缓冲区（ Thread Local Allocation Buffer ， TLAB ）。

​	Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 ``-Xmx`` 和 ``-Xms`` 控制）。

### 2.2.5 方法区

​	方法区（ Method Area ）是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做 Non-Heap （非堆），目的应该是与 Java 对区分开来。

​	这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

### 2.2.6 运行时常量池

​	运行时常量池（ Runtime Constant Pool ）是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（ Constant Pool Table ），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

​	Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被利用得比较多的便是 String 类的 intern() 方法。

> 1. 直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。
>
> 2. new出来的字符串是存放在堆里面。
>
> 3. 对字符串进行拼接操作，也就是做"+"运算的时候，分2种情况：
>
>    i.表达式右边是纯字符串常量，那么存放在栈里面。
>
>    ii.表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面。
>
>    String 的 intern() 把字符串对象加入常量池中。

### 2.2.7 直接内存

​	直接内存（ Direct Memory ）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。

​	在 JDK 1.4 中新加入了 NIO 类，引入了一种基于通道（ Channel ）与缓冲区（ Buffer ）的 I/O 方式，它可以使用 Native 函数库直接分配对外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为该块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

## 2.3 HotSpot 虚拟机对象探秘

### 2.3.1 对象的创建

​	虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，那必须先执行相应的类加载过程。

​	在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存大小在类加载完成后便可完全确定。

​	假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把那个指针向空闲空间那边挪动一端与对象大小相等的距离，这种分配方式称为“指针碰撞”（ Bump the Pointer ）。

​	如果 Java 堆中的内存并不是规整的，已使用的内存和空间的内存相互交错，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（ Free List ）。

​	选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial 、 ParNew 等带 Compact 过程的收集器是，系统采用的分配算法是指针碰撞，而使用  CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。

​	除如何划分可用空间之外，还有另一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅一个修改指针所指向的位置，在并发情况下也并不是线程安全的。解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（ Thread Local Allocation Buffer , TLAB ）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。虚拟机是否使用 TLAB ，可以通过 `` -XX:+/-UseTLAB``参数来设定。

​	内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB ，这一工作也可以提前至 TLAB 分配时进行。这一步操作保证了对象的实例字段在 Java 代码中不赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。

​	接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头（ Object Header ）之中。根据虚拟机当前的运行状态不同，如是否有偏向锁等，对象头会有不同的设置方式。

​	上面工作都完成后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，一般来说（由字节码中是否跟随 invokespecial 指令所决定），执行 new 指令之后会接着执行\< init \>方法。

### 2.3.2 对象的内存布局

​	在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（ Header ）、实例数据（ Instance Data ）和对齐填充（ Padding ）。

​	HotSpot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（ HashCode ）、 GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID 、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32 bit 和64 bit ，官方称它为“ Mark Word ”。对象需要存储的运行时数据很多，其实已经超出了32位、64位 Bitmap 结构所能记录的限度， Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的 Hotspot 虚拟机中，如果对象处于未被锁定的状态下，那么 Mark Word 的32 bit 空间中的25 bit 用于存储对象哈希码，4 bit 用于存储对象分代年龄，2 bit 用于存储锁标志位，1 bit 固定为0，而在其他状态（轻量级锁定、重量级锁定、 GC 标记、可偏向）下对象的存储内容如下。

![Hotspot 虚拟机对象头](resources\MarkWord.png)

​	对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，话句话说，查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是一个数组，还必须有一块用于记录数组长度的数据。

​	无论是从父类集成下来的，还是在子类中定义的，在程序代码中所定义的各种类型的字段内容，都需要记录下来。这部分的存储顺序会受到虚拟机分配策略参数（ FiledsAllocationStyle ）和字段在 Java 源码中定义顺序的影响。 Hotspot 虚拟机默认的分配策略为 longs/doubles 、ints 、 shorts/chars 、bytes/booleans 、 oops （ Ordinary Object Pointers ），从分配策略可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFileds 参数值为 true （默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。

​	第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 Hotspot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。而对象头正好是8字节的整数倍，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

### 2.3.3 对象的访问定位

​	通过何种方式定位、访问堆中对象的具体位置，取决于虚拟机的实现而定的。目前主流的访问方式由使用句柄和直接指针两种。

- 如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池， reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示。

![句柄方式访问对象](resources\句柄方式访问对象.jpg)

- 如果使用直接指针访问，那么 Java 堆对象的布局就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址，如下图所示。

  ![直接指针方式访问对象](resources\直接指针方式访问对象.jpg)

​	使用句柄的最大好处就是 reference 中存储的稳定的句柄地址，在对象被移动（垃圾收集时，移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。

​	使用直接指针访问方式的最大好处就是速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 Sun HotSpot 使用第二种防护四进行对象访问。

### 2.4 实战 OutMemoryError 异常

### 2.4.2 虚拟机栈和本地方法栈溢出

​	操作系统分配给每个进程的内存是有限制的，譬如 32 位的 Windows 限制为 2 GB 。剩余的内存为 2 GB （操作系统限制）减去 Xmx （最大堆容量），再减去 MaxPermSize （最大方法区容量），程序计数器小号内存很小，可以忽略掉。如果虚拟机进程本身消耗的内存不计算在内，剩下的内存就有虚拟机栈和本地方法栈“瓜分”了。

​	如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换 64 位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。

### 2.4.3 方法区和运行时常量池溢出

​	当前的很多主流框架，如 Spring 、 Hibernate ，在对类进行增强是，都会使用到 CGLib 这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的 Class 可以加载入内存。另外， JVM 上的动态语言（如 Groovy 等）通常都会持续创建类来实现动态语言的特性。

​	方法区溢出是一种常见的溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量 Class 的应用中，需要特别注意类的惠州状况。这类场景除了 CGLib 字节码增强和动态语言之外，常见的还有：大量 JSP 或动态产生 JSP文件多的应用（ JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 的应用（即使是同一个类文件，被不同的加载器加载也会被视为不同的类）等。
